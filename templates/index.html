<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Puzzle Break</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <!-- index.html version 2025-05-15-v1 -->
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap" rel="stylesheet">
    <link id="pyscript-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pyscript@2024.11.2/dist/core.css">
    <script id="pyscript-js" defer src="https://cdn.jsdelivr.net/npm/pyscript@2024.11.2/dist/core.js" type="module"></script>
    <style>
        body {
            background: linear-gradient(135deg, #1a1a1a 0%, #2c2c2c 100%);
            color: #fff;
            font-family: 'Bebas Neue', sans-serif;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .container {
            display: flex;
            gap: 20px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            border: 2px solid #00ff00;
            position: relative;
        }
        canvas {
            border: 3px solid #00ff00;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
        }
        #side-piece {
            border: 3px solid #ffd700;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.7);
        }
        #leaderboard {
            background: rgba(0, 255, 0, 0.1);
            padding: 15px;
            border-radius: 10px;
            border: 2px dashed #00ff00;
            min-width: 200px;
            max-height: 400px;
            overflow-y: auto;
        }
        #leaderboard h2 {
            margin: 0 0 10px;
            font-size: 34px;
            color: #00ff00;
        }
        #leaderboard ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #leaderboard li {
            font-size: 24px;
            margin: 5px 0;
        }
        #win-announcement {
            position: fixed;
            transform: translate(-50%, -50%) scale(0);
            font-size: 30px;
            color: #ffffff;
            text-shadow: 0 0 5px #ff00ff, 0 0 10px #ff00ff, 0 0 15px #00ffff, 0 0 20px #00ffff;
            background: rgba(0, 0, 0, 0.9);
            padding: 10px 15px;
            border-radius: 10px;
            border: 4px solid #ffd700;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.9), inset 0 0 15px rgba(255, 215, 0, 0.7);
            z-index: 1000;
            display: none;
            pointer-events: none;
            letter-spacing: 1px;
            max-width: 280px;
            text-align: center;
            white-space: normal;
        }
        #win-announcement:not(.complete) {
            animation: winPop 0.8s ease-out forwards, winGlow 1.2s infinite alternate, fadeOut 2s 3s ease-out forwards;
        }
        #win-announcement.complete {
            animation: winPop 0.8s ease-out forwards, winGlow 1.2s infinite alternate, fadeOut 2s 6s ease-out forwards;
        }
        #confetti-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999;
        }
        p {
            font-size: 28px;
            margin: 10px 0;
            text-align: center;
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
        }
        #side-piece-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #timer-container {
            margin-top: 20px;
            text-align: center;
        }
        #timer-description {
            font-size: 24px;
            color: #ffd700;
            text-shadow: 0 0 5px #ffd700;
            margin-bottom: 10px;
            max-width: 200px;
            line-height: 1.2;
        }
        #cooldown-timer {
            font-size: 48px;
            color: #ffd700;
            text-shadow: 0 0 5px #ffd700;
        }
        #start-button, #test-win-button {
            padding: 10px 20px;
            font-size: 20px;
            font-family: 'Bebas Neue', sans-serif;
            color: #fff;
            background: #00ff00;
            border: 2px solid #ffd700;
            border-radius: 5px;
            cursor: pointer;
            text-shadow: 0 0 5px #000;
            margin: 10px;
        }
        #start-button {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1001;
        }
        #test-win-button {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1001;
        }
        #start-button:hover, #test-win-button:hover {
            background: #ffd700;
            color: #000;
        }
        #error-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.8);
            color: #fff;
            padding: 20px;
            border-radius: 10px;
            z-index: 1002;
            display: none;
            text-align: center;
        }
        #loading-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 30px;
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
        }
        @keyframes winPop {
            0% { transform: translate(-50%, -50%) scale(0) rotate(-15deg); opacity: 0; }
            70% { transform: translate(-50%, -50%) scale(1.1) rotate(5deg); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 1; }
        }
        @keyframes winGlow {
            0% {
                text-shadow: 0 0 5px #ff00ff, 0 0 10px #ff00ff, 0 0 15px #00ffff, 0 0 20px #00ffff;
                box-shadow: 0 0 30px rgba(0, 255, 255, 0.9), inset 0 0 15px rgba(255, 215, 0, 0.7);
                border-color: #ffd700;
            }
            100% {
                text-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff, 0 0 25px #00ffff, 0 0 35px #00ffff;
                box-shadow: 0 0 50px rgba(0, 255, 255, 1), inset 0 0 20px rgba(255, 215, 0, 1);
                border-color: #ff00ff;
            }
        }
        @keyframes fadeOut {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="loading-message">Loading Puzzle Break...</div>
    <button id="start-button" style="display: none;">Click to Start Game</button>
    <button id="test-win-button" style="display: none;">Test Win Animation</button>
    <div class="container" style="display: none;">
        <div>
            <canvas id="grid" width="350" height="350"></canvas>
            <p>Use !g (coordinate)</p>
            <div id="side-piece-container">
                <canvas id="side-piece" width="210" height="210"></canvas>
            </div>
        </div>
        <div>
            <div id="leaderboard">
                <h2>Leaderboard</h2>
                <ul id="leaderboard-list"></ul>
            </div>
            <div id="timer-container">
                <div id="timer-description">
                    See what second you're on when you guess, then guess again when the timer returns to that second.
                </div>
                <div id="cooldown-timer">5</div>
            </div>
        </div>
    </div>
    <div id="win-announcement"></div>
    <canvas id="confetti-canvas"></canvas>
    <div id="error-message"></div>
    <script>
        console.log("Page loaded, initializing JavaScript (version 2025-05-15-v1)...");

        // PyScript fallback
        const pyscriptJs = document.getElementById('pyscript-js');
        pyscriptJs.onerror = () => {
            console.log("jsdelivr.net failed, trying pyscript.net...");
            pyscriptJs.src = "https://pyscript.net/releases/2024.11.2/core.js";
            const pyscriptCss = document.getElementById('pyscript-css');
            pyscriptCss.href = "https://pyscript.net/releases/2024.11.2/core.css";
            setTimeout(() => {
                if (!window.PyScript) {
                    console.error("PyScript failed to load from both CDNs");
                    document.getElementById('error-message').textContent = "Failed to load game scripts. Please refresh or try later.";
                    document.getElementById('error-message').style.display = 'block';
                    document.getElementById('loading-message').style.display = 'none';
                }
            }, 5000);
        };

        // Test PyScript CSS loading
        const pyscriptCss = document.getElementById('pyscript-css');
        pyscriptCss.onerror = () => {
            console.log("jsdelivr.net CSS failed, trying pyscript.net...");
            pyscriptCss.href = "https://pyscript.net/releases/2024.11.2/core.css";
        };

        // Initialize canvas
        const gridCanvas = document.getElementById('grid');
        let gridCtx;
        if (gridCanvas) {
            gridCtx = gridCanvas.getContext('2d');
        } else {
            console.error("Grid canvas not found");
        }
        const confettiCanvas = document.getElementById('confetti-canvas');
        let confettiCtx;
        if (confettiCanvas) {
            confettiCtx = confettiCanvas.getContext('2d');
            confettiCanvas.width = window.innerWidth;
            confettiCanvas.height = window.innerHeight;
        } else {
            console.error("Confetti canvas not found");
        }

        // Window load handler
        window.addEventListener('load', () => {
            console.log("Window load event fired");
            const loadingMessage = document.getElementById('loading-message');
            const startButton = document.getElementById('start-button');
            const errorMessage = document.getElementById('error-message');
            if (!gridCanvas || !gridCtx) {
                console.error("Grid canvas or context not initialized");
                errorMessage.textContent = "Error: Game canvas not loaded. Please refresh.";
                errorMessage.style.display = 'block';
                loadingMessage.style.display = 'none';
                return;
            }
            console.log("Grid canvas found, drawing placeholder grid");
            drawPlaceholderGrid();
            loadingMessage.style.display = 'none';
            startButton.style.display = 'block';
        });

        // Visibility handling
        let animationFrameId = null;
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                console.log("Tab hidden, pausing animations");
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
            } else {
                console.log("Tab visible, resuming animations");
            }
        });

        // Confetti functions
        function createConfetti() {
            console.log("Creating confetti");
            const particles = [];
            if (!gridCanvas) return particles;
            const gridRect = gridCanvas.getBoundingClientRect();
            const centerX = gridRect.left + 175;
            const centerY = gridRect.top + 175;

            for (let i = 0; i < 20; i++) {
                const shapeType = Math.random();
                let shape;
                if (shapeType < 0.4) shape = 'circle';
                else if (shapeType < 0.7) shape = 'square';
                else shape = 'star';

                particles.push({
                    x: centerX,
                    y: centerY,
                    vx: (Math.random() - 0.5) * 12,
                    vy: (Math.random() - 0.5) * 12,
                    color: `hsl(${Math.random() * 360}, 100%, 50%)`,
                    size: Math.random() * 5 + 3,
                    shape: shape,
                    opacity: 1,
                    rotation: Math.random() * 360,
                    rotationSpeed: (Math.random() - 0.5) * 10
                });
            }
            return particles;
        }

        function drawStar(ctx, x, y, size, rotation) {
            if (!ctx) return;
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation * Math.PI / 180);
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                ctx.lineTo(Math.cos((18 + i * 72) * Math.PI / 180) * size, Math.sin((18 + i * 72) * Math.PI / 180) * size);
                ctx.lineTo(Math.cos((54 + i * 72) * Math.PI / 180) * (size / 2), Math.sin((54 + i * 72) * Math.PI / 180) * (size / 2));
            }
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        function animateConfetti(particles) {
            if (!confettiCtx) return;
            confettiCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);
            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2;
                p.vx *= 0.98;
                p.vy *= 0.98;
                p.opacity -= 0.01;
                p.rotation += p.rotationSpeed;

                if (p.y > window.innerHeight || p.x < 0 || p.x > window.innerWidth || p.opacity <= 0) return;

                confettiCtx.globalAlpha = p.opacity;
                confettiCtx.fillStyle = p.color;

                if (p.shape === 'circle') {
                    confettiCtx.beginPath();
                    confettiCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    confettiCtx.fill();
                } else if (p.shape === 'square') {
                    confettiCtx.save();
                    confettiCtx.translate(p.x, p.y);
                    confettiCtx.rotate(p.rotation * Math.PI / 180);
                    confettiCtx.fillRect(-p.size, -p.size, p.size * 2, p.size * 2);
                    confettiCtx.restore();
                } else if (p.shape === 'star') {
                    drawStar(confettiCtx, p.x, p.y, p.size, p.rotation);
                }
            });

            const remainingParticles = particles.filter(p => p.y <= window.innerHeight && p.x >= 0 && p.x <= window.innerWidth && p.opacity > 0);
            if (remainingParticles.length > 0 && !document.hidden) {
                animationFrameId = requestAnimationFrame(() => animateConfetti(remainingParticles));
            }
        }

        window.triggerConfetti = function() {
            const particles = createConfetti();
            animateConfetti(particles);
        };

        // Placeholder grid
        function drawPlaceholderGrid() {
            if (!gridCtx) {
                console.error("Cannot draw grid: gridCtx is undefined");
                return;
            }
            console.log("Drawing placeholder grid");
            gridCtx.clearRect(0, 0, 350, 350);
            const cellSize = 70;
            for (let i = 0; i < 25; i++) {
                const x = (i % 5) * cellSize;
                const y = (i // 5) * cellSize;
                gridCtx.strokeStyle = '#00ff00';
                gridCtx.lineWidth = 3;
                gridCtx.strokeRect(x, y, cellSize, cellSize);
                gridCtx.fillStyle = '#ccffcc';
                gridCtx.font = '30px Bebas Neue';
                gridCtx.textAlign = 'center';
                const coord = String.fromCharCode(65 + (i // 5)) + (i % 5 + 1);
                gridCtx.fillText(coord, x + cellSize/2, y + cellSize/2 + 10);
            }
        }
    </script>
    <script type="py" config='{"packages": ["requests"]}'>
import json
import asyncio
from js import EventSource, fetch, console, document, window, Audio, setTimeout, Image, requestAnimationFrame, cancelAnimationFrame
from pyodide.http import pyfetch
from pyodide.ffi import create_proxy
import time

console.log("PyScript loaded, starting Python initialization (version 2025-05-15-v1)...")

# Canvas setup
grid_canvas = document.getElementById('grid')
grid_ctx = grid_canvas.getContext('2d') if grid_canvas else None
side_canvas = document.getElementById('side-piece')
side_ctx = side_canvas.getContext('2d') if side_canvas else None

# Game state
state = {
    'pieces': {},
    'current_piece': None,
    'natural_section': None,
    'current_image': '',
    'guesses': {},
    'leaderboard': [],
    'sectionMapping': {},
    'reverse_section_mapping': {},
    'baseMapping': {},
    'reverseBaseMapping': {},
    'gameId': 0,
    'pieceId': 0,
    'cooldownSeconds': 5,
    'minPrize': 50,
    'maxPrize': 50
}

# Grid coordinates
grid_coords = [f"{letter}{number}" for letter in "ABCDE" for number in range(1, 6)]
coord_to_index = {coord: i for i, coord in enumerate(grid_coords)}

# Global variables
puzzle_img = None
puzzle_img_url = ''
last_drawn_state = {'pieces': {}, 'guesses': {}}
is_initial_render = True

# Preload audio
win_audio = None
win_audio2 = None
try:
    win_audio = Audio.new('https://gateway.pinata.cloud/ipfs/bafkreichboyu3k7z7qfuxgal22hnjhc3nopll7c7bhmdwv366gz7q6ymqq')  # win_sound.mp3
    win_audio2 = Audio.new('https://gateway.pinata.cloud/ipfs/bafkreifo4kqi53fv5qye7rcijgor53mihtfp2lt5afw76sqivotth7linu')  # win_sound2.mp3
    console.log("Audio preloaded successfully")
except Exception as e:
    console.log(f"Failed to preload audio: {str(e)}")

# Cooldown timer
cooldown_duration = 5
last_timer_update = time.time()
timer_value = cooldown_duration
animation_frame_id = None

# Debouncing
last_processed_timestamp = 0

# Image loading
def load_image_js(url, callback):
    img = Image.new()
    img.src = url
    img.onload = create_proxy(lambda _: callback(img))
    img.onerror = create_proxy(lambda _: callback(None))
    return img

async def load_image(url):
    global puzzle_img
    try:
        loop = asyncio.get_event_loop()
        future = loop.create_future()

        def callback(img):
            if img is None:
                console.log(f"Failed to load image from URL: {url}")
                future.set_exception(Exception(f"Failed to load image: {url}"))
            else:
                console.log(f"Successfully loaded image from URL: {url}")
                future.set_result(img)

        load_image_js(url, create_proxy(callback))
        result = await future
        return result
    except Exception as e:
        console.log(f"Exception in load_image: {str(e)}")
        placeholder_url = 'https://via.placeholder.com/2000x2000.png?text=Image+Failed'
        try:
            future = loop.create_future()
            load_image_js(placeholder_url, create_proxy(callback))
            result = await future
            return result
        except Exception as e:
            console.log(f"Fallback image load failed: {str(e)}")
            placeholder = document.createElement('canvas')
            placeholder.width = 2000
            placeholder.height = 2000
            ctx = placeholder.getContext('2d')
            ctx.fillStyle = 'gray'
            ctx.fillRect(0, 0, 2000, 2000)
            ctx.fillStyle = 'white'
            ctx.font = '100px Arial'
            ctx.textAlign = 'center'
            ctx.fillText('Image Failed', 1000, 1000)
            return placeholder

async def update_image(url):
    global puzzle_img, puzzle_img_url
    if url != puzzle_img_url:
        puzzle_img_url = url
        puzzle_img = await load_image(url)
        draw_grid()
        draw_side_piece()

def draw_grid():
    global is_initial_render
    if not grid_ctx:
        console.log("Cannot draw grid: grid_ctx is None")
        return
    current_piece_count = len(state['pieces'])
    last_piece_count = len(last_drawn_state['pieces'])
    if not is_initial_render and current_piece_count < last_piece_count:
        console.log(f"Piece count mismatch: current={current_piece_count}, last={last_piece_count}, forcing full redraw")
        is_initial_render = True

    if is_initial_render:
        grid_ctx.clearRect(0, 0, 350, 350)
        cell_size = 70
        for i in range(25):
            x = (i % 5) * cell_size
            y = (i // 5) * cell_size
            grid_ctx.strokeStyle = '#00ff00'
            grid_ctx.lineWidth = 3
            grid_ctx.strokeRect(x, y, cell_size, cell_size)

            coord = grid_coords[i]
            if coord in state['pieces']:
                section = state['pieces'][coord]
                col = section % 5
                row = section // 5
                if puzzle_img:
                    try:
                        grid_ctx.drawImage(
                            puzzle_img,
                            col * 400, row * 400, 400, 400,
                            x, y, cell_size, cell_size
                        )
                    except Exception:
                        grid_ctx.fillStyle = 'green'
                        grid_ctx.fillRect(x, y, cell_size, cell_size)
                        grid_ctx.fillStyle = 'white'
                        grid_ctx.font = '30px Bebas Neue'
                        grid_ctx.textAlign = 'center'
                        grid_ctx.fillText("P", x + cell_size/2, y + cell_size/2 + 10)
                else:
                    grid_ctx.fillStyle = 'green'
                    grid_ctx.fillRect(x, y, cell_size, cell_size)
                    grid_ctx.fillStyle = 'white'
                    grid_ctx.font = '30px Bebas Neue'
                    grid_ctx.textAlign = 'center'
                    grid_ctx.fillText("P", x + cell_size/2, y + cell_size/2 + 10)
            elif coord in state['guesses'] and state['guesses'][coord] == 'miss':
                grid_ctx.fillStyle = 'rgba(255, 0, 0, 0.2)'
                grid_ctx.fillRect(x, y, cell_size, cell_size)
                grid_ctx.fillStyle = 'red'
                grid_ctx.font = '40px Bebas Neue'
                grid_ctx.textAlign = 'center'
                grid_ctx.fillText('X', x + cell_size/2, y + cell_size/2 + 10)
            else:
                grid_ctx.fillStyle = '#ccffcc'
                grid_ctx.font = '30px Bebas Neue'
                grid_ctx.textAlign = 'center'
                grid_ctx.fillText(coord, x + cell_size/2, y + cell_size/2 + 10)
        is_initial_render = False
        last_drawn_state['pieces'] = dict(state['pieces'])
        last_drawn_state['guesses'] = dict(state['guesses'])
    else:
        cell_size = 70
        for i in range(25):
            coord = grid_coords[i]
            current_piece = state['pieces'].get(coord)
            current_guess = state['guesses'].get(coord)
            last_piece = last_drawn_state['pieces'].get(coord)
            last_guess = last_drawn_state['guesses'].get(coord)

            if current_piece != last_piece or current_guess != last_guess or (last_piece is not None and current_piece is None):
                x = (i % 5) * cell_size
                y = (i // 5) * cell_size
                grid_ctx.clearRect(x, y, cell_size, cell_size)
                grid_ctx.strokeStyle = '#00ff00'
                grid_ctx.lineWidth = 3
                grid_ctx.strokeRect(x, y, cell_size, cell_size)

                if coord in state['pieces']:
                    section = state['pieces'][coord]
                    col = section % 5
                    row = section // 5
                    if puzzle_img:
                        try:
                            grid_ctx.drawImage(
                                puzzle_img,
                                col * 400, row * 400, 400, 400,
                                x, y, cell_size, cell_size
                            )
                        except Exception:
                            grid_ctx.fillStyle = 'green'
                            grid_ctx.fillRect(x, y, cell_size, cell_size)
                            grid_ctx.fillStyle = 'white'
                            grid_ctx.font = '30px Bebas Neue'
                            grid_ctx.textAlign = 'center'
                            grid_ctx.fillText("P", x + cell_size/2, y

System: I'm sorry, but it looks like your message was cut off. The F12 errors you provided indicate persistent issues with the Content Security Policy (CSP) blocking `unsafe-eval`, a stylesheet (`core.css`) failing to load, and Cross-Origin Read Blocking (CORB) affecting `core.css`. These are preventing PyScript from initializing, causing the "LOADING PUZZLE BREAK" issue on `https://nftopia-puzzle.onrender.com`. I'll address these based on the provided errors and the context of our previous discussions, including your IPFS CIDs, the `ConsumerBreak` channel, and the `break__bot` bot.

### Analysis of F12 Errors
1. **CSP Blocking `unsafe-eval`**:
   - **Error**: "Content Security Policy of your site blocks the use of 'eval' in JavaScript."
   - **Cause**: The CSP in `main.py` includes `unsafe-eval` in `script-src`, but it’s not being applied correctly, possibly due to:
     - Render.com overriding the CSP with a default policy.
     - A misconfiguration in Flask or Hypercorn.
     - A syntax error or incomplete CSP application.
   - **Impact**: PyScript requires `unsafe-eval` to execute its WebAssembly and Python interpreter, so this block halts initialization.

2. **Stylesheet Loading Failure**:
   - **Error**: "This page failed to load a stylesheet from a URL" (`core.css` at `nftopia-puzzle.onrender.com/:11`).
   - **Cause**: The PyScript stylesheet (`https://pyscript.net/releases/2024.11.2/core.css`) is blocked, likely by:
     - CSP `style-src` missing `https://pyscript.net` or `https://cdn.jsdelivr.net`.
     - Network issues or server misconfiguration at `pyscript.net`.
   - **Line Reference**: Line 11 in `index.html` is the PyScript CSS link:
     ```html
     <link id="pyscript-css" rel="stylesheet" href="https://pyscript.net/releases/2024.11.2/core.css">
     ```

3. **CORB Blocking `core.css`**:
   - **Error**: "Cross-Origin Read Blocking (CORB) blocked a cross-origin response" for `core.css`.
   - **Cause**: The browser’s CORB mechanism blocks `core.css` because:
     - The server at `pyscript.net` doesn’t send proper `Access-Control-Allow-Origin` headers.
     - The CSP’s `connect-src` or `style-src` doesn’t allow cross-origin requests to `pyscript.net`.
   - **Impact**: Without `core.css`, PyScript’s UI components fail, contributing to the loading issue.

### Updated Strategy
Since the previous code included `unsafe-eval` and appropriate `style-src`/`connect-src` directives but still failed, I’ll:
1. **Force CSP Application**:
   - Explicitly set `Content-Security-Policy` and remove any conflicting headers.
   - Add verbose logging to confirm CSP application in Render logs.
   - Simplify the CSP to focus on essential domains (`pyscript.net`, `cdn.jsdelivr.net`, `gateway.pinata.cloud`).
2. **Bypass `pyscript.net` Issues**:
   - Default to `cdn.jsdelivr.net` for PyScript’s JS and CSS to avoid CORB and loading issues with `pyscript.net`.
   - Remove fallback logic to simplify debugging.
3. **Test Alternative PyScript Version**:
   - Use PyScript `2024.10.1` instead of `2024.11.2` to rule out version-specific bugs.
4. **Maintain Existing Functionality**:
   - Keep your IPFS CIDs for puzzle images and audio.
   - Ensure compatibility with `ConsumerBreak` channel and `break__bot` bot.
   - Retain Google Sheets integration and game mechanics.

### Updated Code
Below are the updated `main.py` and `index.html` files, incorporating your IPFS CIDs and addressing the CSP, stylesheet, and CORB issues. The `requirements.txt` remains unchanged.

#### `main.py`
```python
import asyncio
import json
import os
import random
import time
from threading import Thread

import gspread
import requests
from flask import Flask, Response, jsonify, render_template, make_response
from flask_cors import CORS
from google.oauth2.service_account import Credentials
from twitchio.ext import commands

app = Flask(__name__)
CORS(app)

# Version Marker
app.logger.info("Running main.py version 2025-05-16-v1")

# Debug Environment Variables
app.logger.info("Listing environment variable keys: %s", list(os.environ.keys()))

# Twitch Bot Configuration
BOT_TOKEN = os.getenv('TWITCH_BOT_TOKEN')
BOT_NICK = 'break__bot'
app.logger.info(f"TWITCH_BOT_TOKEN is set: {'True' if BOT_TOKEN else 'False'}")
if not BOT_TOKEN:
    app.logger.warning("TWITCH_BOT_TOKEN not set. Bot functionality will be disabled.")
CHANNELS = ['ConsumerBreak']
bot = None

# Game State
game_state = {
    'pieces': {},
    'guesses': {},
    'current_piece': None,
    'natural_section': None,
    'current_image': '',
    'leaderboard': [],
    'sectionMapping': {},
    'reverse_section_mapping': {},
    'baseMapping': {},
    'reverseBaseMapping': {},
    'gameId': 0,
    'pieceId': 0,
    'cooldownSeconds': 60,
    'minPrize': 1,
    'maxPrize': 50
}
puzzle_images = []
image_index = 0
event_queue = []
last_event_timestamp = 0

# Google Sheets Setup
SCOPES = ['https://www.googleapis.com/auth/spreadsheets']
SPREADSHEET_ID = '1amJa8alcwRwX-JnhbPjdrAUk16VXxlKjmWwXDCFvjSU'
sheet = None
credentials_json = os.getenv('GOOGLE_CREDENTIALS')
if credentials_json:
    try:
        credentials_dict = json.loads(credentials_json)
        creds = Credentials.from_service_account_info(credentials_dict, scopes=SCOPES)
        client = gspread.authorize(creds)
        sheet = client.open_by_key(SPREADSHEET_ID).sheet1
        app.logger.info("Google Sheets initialized successfully")
    except Exception as e:
        app.logger.error(f"Failed to initialize Google Sheets: {str(e)}")
        sheet = None
else:
    app.logger.warning("GOOGLE_CREDENTIALS not set. Leaderboard functionality will be disabled.")

# Initialize Puzzle Images (IPFS)
def init_puzzle_images():
    global puzzle_images, image_index
    ipfs_base_url = "https://gateway.pinata.cloud/ipfs/"
    ipfs_cids = [
        "bafybeice6fyptk5efjq63v5pci5whoqzhn47gwpssgd5g7kowmwmeq3buq",  # puzzle01_00000.png
        "bafybeicgmjfdclavzgt6wchopfnentwvw6c2jj7rk4jv4tbt5uoow7bmcy",  # puzzle02_00000.png
        "bafybeib5pg5el6whrqot3ap23amm6vhzx2n3ukjuac4kvznjornzy5iapq",  # puzzle03_00000.png
        "bafybeihyxddn2p6ymdqa6qtujbphtcg6sftnkjmgp5lxiahl2szirj56ji",  # puzzle04_00000.png
        "bafybeidkmchhllfiyuuamyrwfnh7kqomfo6mrrqrmfxvabqk5c4uakgcia",  # puzzle05_00000.png
        "bafybeic67y5b6iijp3tgt6twilxk2iwlh3owlgpwitq7xravdbcv7jojw4",  # puzzle06_00000.png
        "bafybeigvfq3g6lgazhas6ahq4xt27udj35p7mgndqplldydhz5c3327rau"   # puzzle07_00000.png
    ]
    puzzle_images = [f"{ipfs_base_url}{cid}" for cid in ipfs_cids]
    
    app.logger.info(f"Initialized with {len(puzzle_images)} puzzle images: {puzzle_images}")
    if puzzle_images:
        game_state['current_image'] = puzzle_images[0]
        app.logger.info(f"Set initial current_image to: {game_state['current_image']}")
        image_index = 0
    else:
        app.logger.error("No puzzle images found. Game will not function correctly.")

# Initialize Game
def init_game():
    global image_index
    if not puzzle_images:
        app.logger.error("No puzzle images available. Cannot initialize game.")
        return
    game_state['gameId'] += 1
    app.logger.info(f"Initializing puzzle for game ID {game_state['gameId']}")
    game_state['pieces'] = {}
    game_state['guesses'] = {}
    game_state['pieceId'] = 0
    sections = list(range(25))
    random.shuffle(sections)
    game_state['sectionMapping'] = {str(i): sections[i] for i in range(25)}
    game_state['reverse_section_mapping'] = {str(sections[i]): i for i in range(25)}
    game_state['baseMapping'] = game_state['sectionMapping'].copy()
    game_state['reverseBaseMapping'] = game_state['reverse_section_mapping'].copy()
    app.logger.info(f"Section mapping created: {game_state['sectionMapping']}")
    game_state['current_piece'] = 0
    game_state['natural_section'] = game_state['sectionMapping']['0']
    expected_row = game_state['natural_section'] // 5
    expected_col = game_state['natural_section'] % 5
    expected_coord = f"{chr(65 + expected_row)}{expected_col + 1}"
    app.logger.info(f"Set initial piece: current_piece={game_state['current_piece']}, natural_section={game_state['natural_section']}, expected_coord={expected_coord}")
    image_index = (image_index + 1) % len(puzzle_images)
    game_state['current_image'] = puzzle_images[image_index]
    app.logger.info(f"Selected puzzle image: {game_state['current_image']} (index {image_index + 1})")
    game_state['pieceId'] += 1
    app.logger.info(f"Puzzle initialized: game_id={game_state['gameId']}, piece_id={game_state['pieceId']}")
    send_state_update()

# Load Leaderboard
def load_leaderboard():
    if not sheet:
        app.logger.warning("Google Sheets not available. Returning empty leaderboard.")
        game_state['leaderboard'] = []
        return
    try:
        records = sheet.get_all_values()
        app.logger.info(f"Fetched records from sheet: {records}")
        leaderboard_dict = {}
        for row in records[1:]:
            if len(row) >= 2 and row[0] and row[1]:
                username = row[0].strip()
                try:
                    wins = int(row[1])
                    leaderboard_dict[username] = wins
                except ValueError:
                    continue
        app.logger.info(f"Parsed leaderboard: {leaderboard_dict}")
        game_state['leaderboard'] = sorted(leaderboard_dict.items(), key=lambda x: x[1], reverse=True)
        app.logger.info("Successfully loaded leaderboard from sheet")
    except Exception as e:
        app.logger.error(f"Failed to load leaderboard: {str(e)}")
        game_state['leaderboard'] = []

# Update Leaderboard
def update_leaderboard(username):
    if not sheet:
        app.logger.warning("Google Sheets not available. Skipping leaderboard update.")
        return
    try:
        records = sheet.get_all_values()
        leaderboard_dict = {row[0]: int(row[1]) for row in records[1:] if len(row) >= 2 and row[0] and row[1]}
        leaderboard_dict[username] = leaderboard_dict.get(username, 0) + 1
        updated_records = [['Username', 'Wins']] + [[k, str(v)] for k, v in leaderboard_dict.items()]
        sheet.clear()
        sheet.update('A1', updated_records)
        game_state['leaderboard'] = sorted(leaderboard_dict.items(), key=lambda x: x[1], reverse=True)
    except Exception as e:
        app.logger.error(f"Failed to update leaderboard: {str(e)}")

# Send State Update
def send_state_update():
    global last_event_timestamp
    last_event_timestamp = time.time()
    event = {
        'type': 'state',
        'state': game_state.copy(),
        'event': {},
        'timestamp': last_event_timestamp
    }
    app.logger.info(f"Sent state update event: {json.dumps(event)}")
    event_queue.append(event)

# Twitch Bot
class Bot(commands.Bot):
    def __init__(self):
        super().__init__(token=BOT_TOKEN, prefix='!', initial_channels=CHANNELS, nick=BOT_NICK)

    async def event_ready(self):
        app.logger.info(f"Bot connected to Twitch! Nick: {self.nick}, Channels: {self.connected_channels}")

    async def event_message(self, message):
        if message.author.name.lower() == self.nick.lower():
            return
        await self.handle_commands(message)

    @commands.command()
    async def g(self, message):
        username = message.author.name.lower()
        guess = message.content.split(' ', 1)[1].strip().upper() if ' ' in message.content else None
        if not guess or len(guess) < 2 or guess[0] not in 'ABCDE' or not guess[1:].isdigit() or int(guess[1:]) < 1 or int(guess[1:]) > 5:
            await message.channel.send(f"@{username} Invalid coordinate! Use !g <coordinate> (e.g., !g A1)")
            return
        row = ord(guess[0]) - 65
        col = int(guess[1:]) - 1
        section = row * 5 + col
        natural_section = game_state['natural_section']
        if guess in game_state['pieces']:
            await message.channel.send(f"@{username} That spot is already revealed!")
            return
        if guess in game_state['guesses'] and game_state['guesses'][guess] == 'miss':
            await message.channel.send(f"@{username} You already guessed that spot!")
            return
        game_state['guesses'][guess] = 'miss'
        if section == natural_section:
            game_state['pieces'][guess] = natural_section
            prize = random.randint(game_state['minPrize'], game_state['maxPrize'])
            await message.channel.send(f"@{username} found a piece at {guess}! You won {prize} NFTOKEN!")
            update_leaderboard(username)
            event = {
                'type': 'win',
                'state': game_state.copy(),
                'event': {'winner': username, 'prize': prize},
                'timestamp': time.time()
            }
            event_queue.append(event)
            game_state['current_piece'] += 1
            game_state['pieceId'] += 1
            if game_state['current_piece'] >= 25:
                prize = random.randint(game_state['minPrize'], game_state['maxPrize'])
                await message.channel.send(f"Puzzle completed! Everyone wins {prize} NFTOKEN!")
                event = {
                    'type': 'complete',
                    'state': game_state.copy(),
                    'event': {'prize': prize},
                    'timestamp': time.time()
                }
                event_queue.append(event)
                init_game()
            else:
                game_state['natural_section'] = game_state['sectionMapping'][str(game_state['current_piece'])]
                send_state_update()
        else:
            await message.channel.send(f"@{username} guessed {guess} - no piece there!")
            send_state_update()

# Flask Routes
@app.route('/')
def index():
    app.logger.info("Rendering index.html version 2025-05-16-v1")
    try:
        csp = (
            "default-src 'self' https://cdn.jsdelivr.net; "
            "script-src 'self' https://cdn.jsdelivr.net 'unsafe-eval' 'unsafe-inline'; "
            "style-src 'self' https://cdn.jsdelivr.net https://fonts.googleapis.com 'unsafe-inline'; "
            "font-src 'self' https://fonts.gstatic.com; "
            "connect-src 'self' ws: wss: https://cdn.jsdelivr.net https://gateway.pinata.cloud; "
            "img-src 'self' https://gateway.pinata.cloud data:; "
            "worker-src 'self' blob:; "
            "object-src 'none'; "
            "base-uri 'self'; "
            "form-action 'self'"
        )
        app.logger.info(f"Applying CSP: {csp}")
        response = make_response(render_template('index.html'))
        response.headers['Content-Security-Policy'] = csp
        # Remove any conflicting headers
        response.headers.pop('X-Content-Security-Policy', None)
        response.headers.pop('X-WebKit-CSP', None)
        return response
    except Exception as e:
        app.logger.error(f"Failed to render index.html: {str(e)}")
        return "Error rendering page", 500

@app.route('/game_state')
def get_game_state():
    load_leaderboard()
    app.logger.info(f"Returning game state with current_image: {game_state['current_image']}")
    return jsonify(game_state)

@app.route('/events')
def events():
    def stream():
        while True:
            if event_queue:
                event = event_queue.pop(0)
                yield f"data: {json.dumps(event)}\n\n"
            time.sleep(0.1)
    return Response(stream(), mimetype='text/event-stream')

# Start Twitch Bot
def run_bot():
    global bot
    if not BOT_TOKEN:
        app.logger.error("Cannot start Twitch bot: TWITCH_BOT_TOKEN is not set")
        return
    app.logger.info("Starting Twitch bot...")
    time.sleep(5)
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    bot = Bot()
    try:
        bot.run()
    except Exception as e:
        app.logger.error(f"Twitch bot failed: {str(e)}")
    finally:
        loop.close()

if __name__ == '__main__':
    app.logger.info("Main script starting")
    init_puzzle_images()
    init_game()
    load_leaderboard()
    Thread(target=run_bot, daemon=True).start()
    app.logger.info("Starting Flask on port 10000 with hypercorn")
    from hypercorn.config import Config
    from hypercorn.asyncio import serve
    config = Config()
    config.bind = ["0.0.0.0:10000"]
    asyncio.run(serve(app, config))
